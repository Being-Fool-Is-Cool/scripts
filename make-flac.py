#!/usr/bin/env python3
# vim:fileencoding=utf-8:ft=python
#
# Author: R.F. Smith <rsmith@xs4all.nl>
# Created: 2014-08-12 14:37:50 +0200
# Last modified: 2015-05-03 22:07:38 +0200
#
# To the extent possible under law, Roland Smith has waived all copyright and
# related or neighboring rights to make-flac.py. This work is published from
# the Netherlands. See http://creativecommons.org/publicdomain/zero/1.0/

"""Encodes WAV files from cdparanoia to FLAC format. Processing is
done in parallel using as many subprocesses as the machine has
cores. Title and song information is gathered from a text file called
titles.
"""

__version__ = '1.0.0'

from multiprocessing import cpu_count
from time import sleep
import os
import subprocess
import sys


def checkfor(args, rv=0):
    """Make sure that a program necessary for using this script is
    available.

    :param args: String or list of strings of commands. A single string may
    not contain spaces.
    :param rv: Expected return value from evoking the command.
    """
    if isinstance(args, str):
        if ' ' in args:
            raise ValueError('no spaces in single command allowed')
        args = [args]
    try:
        with open(os.devnull, 'w') as bb:
            rc = subprocess.call(args, stdout=bb, stderr=bb)
        if rc != rv:
            raise OSError
    except OSError as oops:
        outs = "Required program '{}' not found: {}."
        print(outs.format(args[0], oops.strerror))
        sys.exit(1)


def trackdata(fname='titels'):
    """Read the data describing the tracks from a text file.

    Arguments:
    fname -- name of the text file describing the tracks.

    This file has the following format:

      album title
      artist
      01 title of 1st song
      ..
      14 title of 14th song

    Returns:
    A list of tuples. Each tuple contains the track number, title of
    the track, name of the artist, name of the album, input file name
    and output file name.
    """
    tracks = []
    try:
        with open(fname, 'r') as tf:
            lines = tf.readlines()
    except IOError:
        return tracks
    album = lines.pop(0).strip()
    artist = lines.pop(0).strip()
    for l in lines:
        words = l.split()
        if not words:
            continue
        num = int(words.pop(0))
        # These are the default WAV file names generated by cdparanoia.
        ifname = 'track{:02d}.cdda.wav'.format(num)
        if os.access(ifname, os.R_OK):
            ofname = 'track{:02d}.flac'.format(num)
            title = ' '.join(words)
            tracks.append((num, title, artist, album, ifname, ofname))
    return tracks


def startflac(tinfo):
    """Use the flac(1) program to convert the music to FLAC format.

    Arguments:
    tinfo -- a tuple containing the track number, title of the track,
    name of the artist, name of the album, input file name and output
    file name.

    Returns:
    A tuple containing the output filename and the Popen object
    for the running conversion.
    """
    num, title, artist, album, ifname, ofname = tinfo
    args = ['flac', '--best', '--totally-silent', '-TARTIST=' + artist,
            '-TALBUM=' + album, '-TTITLE=' + title,
            '-TTRACKNUM={:02d}'.format(num), '-o', ofname, ifname]
    with open(os.devnull, 'w') as bb:
        p = subprocess.Popen(args, stdout=bb, stderr=bb)
    print('Start processing "{}" as {}'.format(title, ofname))
    return (ofname, p)


def manageprocs(proclist):
    """Check a list of subprocesses for processes that have ended and
    remove them from the list.
    """
    for it in proclist:
        fn, pr = it
        result = pr.poll()
        if result is not None:
            proclist.remove(it)
            if result == 0:
                print('Finished processing', fn)
            else:
                s = 'The conversion of {} exited with error code {}.'
                print(s.format(fn, result))
    sleep(0.5)


def main(argv):
    """Main program."""
    checkfor('flac')
    procs = []
    tracks = trackdata()
    if not tracks:
        print('No tracks found.')
        binary = os.path.basename(argv[0])
        print("{} version {}".format(binary, __version__), file=sys.stderr)
        print("Usage: {}".format(binary), file=sys.stderr)
        print("In a directory where a file 'titels' and WAV files are present",
              file=sys.stderr)
        sys.exit(1)
    maxprocs = cpu_count()
    for track in tracks:
        while len(procs) == maxprocs:
            manageprocs(procs)
        procs.append(startflac(track))
    while len(procs) > 0:
        manageprocs(procs)


if __name__ == '__main__':
    main(sys.argv)
